object ForComprehensions extends App {
  // Scala offers a lightweight notation for expressing
  // sequence comprehensions.


  // Comprehensions have the form for (enumerators) yield e,
  // where enumerators refers to a semicolon-separated list
  // of enumerators. An enumerator is either a generator
  // which introduces new variables, or it is a filter.
  // A comprehension evaluates the body e for each binding
  // generated by the enumerators and returns a sequence of
  // these values.
  case class User(name: String, age: Int)

  val userBase: List[User] = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23))

  val twentySomethings: List[String] =
    for user <- userBase if user.age >=20 && user.age < 30
      yield user.name  // i.e. add this to a list

  twentySomethings.foreach(println)  // prints Travis Dennis


  // A more complicated example using two generators:
  def foo(n: Int, v: Int) =
    for i <- 0 until n
        j <- 0 until n if i + j == v
    yield (i, j)

  foo(10, 10).foreach((i, j) => println(s"($i, $j) "))
  // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)


  // Note that comprehensions are not restricted to lists.
  // Every datatype that supports the operations withFilter,
  // map, and flatMap (with the proper types) can be used
  // in sequence comprehensions.


  // You can omit yield in a comprehension. In that case,
  // comprehension will return Unit. This can be useful in
  // case you need to perform side-effects. Hereâ€™s a program
  // equivalent to the previous one, but without using yield:
  def fooWithoutYield(n: Int, v: Int): Unit =
    for i <- 0 until n
        j <- 0 until n if i + j == v
    do println(s"($i, $j)")

  fooWithoutYield(10, 10)
}